
import { Rule } from './types';

// Predefined rules from the paper
export const PREDEFINED_RULES: { [key: string]: Rule } = {
    majority: Array(128).fill(0).map((_, i) => (i.toString(2).padStart(7, '0').split('').reduce((sum, bit) => sum + parseInt(bit, 10), 0) > 3 ? 1 : 0)),
    
    // Simplified approximation of particle-based rule Ï†17083
    particle: [
        0,0,1,1,0,0,0,0, 0,1,0,0,0,0,0,1,
        0,1,1,1,0,0,0,0, 0,0,1,1,1,1,1,1,
        1,1,0,1,0,1,0,1, 1,1,0,1,1,1,1,1,
        0,0,1,1,0,1,1,1, 0,1,0,1,1,1,1,1,
        0,1,0,1,0,1,1,1, 1,0,0,1,1,1,1,1,
        1,1,0,1,1,1,1,1, 0,1,1,1,1,1,1,1,
        0,1,1,1,0,1,1,1, 1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1
    ],
      
    // GKL rule (Gacs-Kurdyumov-Levin) - a robust rule
    gkl: [
        0,1,0,1,0,1,0,1, 1,0,1,0,1,0,1,0,
        0,1,0,1,0,1,0,1, 1,0,1,0,1,0,1,0,
        0,1,0,1,1,0,1,0, 1,0,1,0,0,1,0,1,
        0,1,0,1,1,0,1,0, 1,0,1,0,0,1,0,1,
        0,1,1,0,0,1,1,0, 1,0,0,1,1,0,0,1,
        0,1,1,0,0,1,1,0, 1,0,0,1,1,0,0,1,
        0,1,1,0,1,0,0,1, 1,0,0,1,0,1,1,0,
        0,1,1,0,1,0,0,1, 1,0,0,1,0,1,1,0
    ],

    expand: [
        0,1,1,1,1,1,1,1, 0,1,1,1,1,1,1,1,
        0,1,1,1,1,1,1,1, 0,1,1,1,1,1,1,1,
        0,1,1,1,1,1,1,1, 0,1,1,1,1,1,1,1,
        0,1,1,1,1,1,1,1, 0,1,1,1,1,1,1,1,
        0,1,1,1,1,1,1,1, 0,1,1,1,1,1,1,1,
        0,1,1,1,1,1,1,1, 0,1,1,1,1,1,1,1,
        0,1,1,1,1,1,1,1, 0,1,1,1,1,1,1,1,
        0,1,1,1,1,1,1,1, 0,1,1,1,1,1,1,1
    ]
};
